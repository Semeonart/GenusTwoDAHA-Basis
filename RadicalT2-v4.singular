//------------------------------------------------------------------------------------------------------------
//   The following program verifies that defining ideal of A_{q=t=1} equals to its radical.
//   Intermediate calculations are stored in *.ssi files to avoid recomputing them at each launch.
//   You are welcome to use precomputed *.ssi files from GitHub, which were generated in Singular 4.1.2.
//   Note that *.ssi files might be incompatible between different versions of Singular, if that becomes an issue you can always clear the cache and then program recomputes everything on your computer.
//   Versions 4.1.2 and 4.1.3 are recomended to run this code, but without the cache files this program should work with almost any version of Singular.
//------------------------------------------------------------------------------------------------------------
LIB "mprimdec.lib";
//----------Defining name of the output file--------
int vnum=2;
int debug=1;
if (debug) {
	string directory="./cache";
} else {
	string directory="/scratch/semeon/Radical";
}
string Orels_filename=directory+"/Aq1t1_relations.txt";
string Rad1_filename=directory+"/Radical_T2_Rad1.ssi";
string Quot1_h1_filename=directory+"/Quot1_h1_T2.ssi";
string Quot1_h2_filename=directory+"/Quot1_h2_T2.ssi";
//-------Procedure for loading cached results---------
proc CachedCalculation(proc F_0, ideal I_0, string cache_filename) {
	if (status(cache_filename,"exists")=="yes") {
		ideal ans=read("ssi:r "+cache_filename);
	} else {
		ideal ans=F_0(I_0);
		write("ssi:w "+cache_filename,stdans);
	}
	return(ans);
}
//-------Procedure to test that ideal is zero------
proc TestZero (ideal I_0) {
	I_0;
	if (size(I_0)==0) {
		return("Ok")
	} else {
		print("The above ideal has failed to be zero!");
		quit;
	}
}
//-------------Defining underlying ring-------------
ring Oring=0,(o,m,n,l,k,j,i,h,g,f,e,d,c,b,a),(wp(3,3,3,2,2,2,2,2,2),dp(6));
ideal Orels=-2*a + c*e - i*j + d*o, -2*b + d*f - j*k + e*m, -2*c + a*e - k*l + f*n, -2*d + b*f - g*l + a*o, a*c - 2*e - g*h + b*m, b*d - 2*f - h*i + c*n, 2*a*b - 2*g - e*h - d*l + j*n, 2*b*c - e*g - 2*h - f*i + k*o, 2*c*d - f*h - 2*i - a*j + l*m, 2*d*e - a*i - 2*j - b*k + g*n, 2*e*f - b*j - 2*k - c*l + h*o, 2*a*f - d*g - c*k - 2*l + i*m, -(a*d) + 2*a*b*f - 2*f*g - h*k - 2*b*l + m*n + 2*o, 2*a*b*c - b*e - 2*c*g - 2*a*h - i*l + 2*m + n*o, 2*b*c*d - c*f - 2*d*h - 2*b*i - g*j + 2*n + m*o, -(a*d) + 2*c*d*e - 2*e*i - 2*c*j - h*k + m*n + 2*o, -(b*e) + 2*d*e*f - 2*f*j - 2*d*k - i*l + 2*m + n*o, -(c*f) + 2*a*e*f - g*j - 2*a*k - 2*e*l + 2*n + m*o, 8 - a*c*e - b*d*f + a*b*g - g2 + b*c*h - h2 + c*d*i - i2 + d*e*j - j2 + e*f*k - k2 + a*f*l - l2 - b*e*m - c*f*n - a*d*o + m*n*o;
ideal stdOrels=groebner(Orels);
//-------------Options for standard basis-------------
option(prot);
option(redSB);
option(noredefine);
ideal stdOrels=groebner(Orels);
//---Comparing defining ideal with the one generated by Mathematica------
if (status(Orels_filename,"exists")=="yes") {
	execute("ideal Orels_Mathematica="+read(Orels_filename));
	print("Testing that ideal used in Mathematica is contained in Orels (basic consistency between the two programs).");
	TestZero(simplify(reduce(Orels_Mathematica,stdOrels),7));
	ideal Orels_Mathematica_std=groebner(Orels_Mathematica);
	print("Testing that ideal used in Mathematica contains Orels. (basic consistency between the two programs).");
	TestZero(simplify(reduce(Orels,Orels_Mathematica_std),7));
} else {
	print("Warning: Cannot load defining ideal generated by Mathematica from "+Orels_filename+". Will skip comparisson and use local definition.");
}
//-------Defining zero-dimensional ring #1 with radical------
ring newring=(0,a,b,c,d,e,f),(o,m,n,l,k,j,i,h,g),wp(3,3,3,2,2,2,2,2,2);
ideal Onew=imap(Oring,stdOrels);
ideal Onew_std=groebner(Onew);
print("Verifying that defining ideal #1 is 0-dimensional");
dim(Onew_std);
//-----------------------------------------------------------------------
//   The following command would obtain radical of 0-dimensional ideal. The result will be saved in cache file to avoid recomputing it each time.
//   First time it will use about 1.5G of memory and the calculation should take between 6 and 12 hours on average 2023 computer with Singular 4.1.2. There might be a slight variation in time caused by different choices of random change of variables which is used by Singular to bring the ideal to generic position w.r.t. lexicographic order.
//-----------------------------------------------------------------------
list rad1list=CachedCalculation(radical,Onew,Rad1_filename);
ideal rad1_std=groebner(rad1list[1]);
print("Verifying that Onew is contained in rad1 (self-consistency)");
TestZero(simplify(reduce(Onew_std,rad1_std),7));
print("Verifying that rad1 is contained in Onew");
TestZero(simplify(reduce(rad1_std,Onew_std),7));
//-------Reading off hpoly from leading coefficients---------------------
proc LCMpoly(poly poly1,poly poly2) {
	//print("poly1="+string(poly1));
	//print("poly2="+string(poly2));
	//print("gcd="+string(gcd(poly1,poly2)));
	return(poly1*poly2/gcd(poly1,poly2))
}
proc GetH(topcoeff) {
	print("Computing the LCM of leading coefficients in Groebner basis for ring "+nameof(basering));
	poly ans=1;
	for (int num=1;num<=size(topcoeff);num++) {
		//print(topcoeff[num]);
		execute("poly newcoeff="+topcoeff[num]+";");
		ans=LCMpoly(ans,newcoeff);
		//print(string(newcoeff)+" -> ");
		//factorize(ans);
	}
	print(factorize(ans));
	return(ans);
}
list topcoeff=list();
for (int r=1;r<=size(Onew);r++)	{
	topcoeff=insert(topcoeff,string(leadcoef(Onew[r])));
}
setring Oring;
poly hpoly=GetH(topcoeff);
//---------------Computing quotient by h^1-----------------------------
proc Quotient1(ideal Hk) {
	return(groebner(quotient(Orels,Hk)));
};
ideal Quot1_h1_std=CachedCalculation(Quotient1,ideal(hpoly),Quot1_h1_filename);
print("Quot1_h1_std is computed, verifying that it contains stdOrels (self-consistency).");
TestZero(simplify(reduce(stdOrels,Quot1_h1_std),7));
print("Verifying that Quot1_h1_std is contained in stdOrels");
TestZero(simplify(reduce(Quot1_h1_std,stdOrels),7));
//--------------Computing quotient by h^2------------------------------
ideal Quot1_h2_std=CachedCalculation(Quotient1,ideal(hpoly*hpoly),Quot1_h2_filename);
print("Quot1_h2_std is computed, verifying that it contains Quot1_h1_std (self-consistency).");
TestZero(simplify(reduce(Quot1_h1_std,Quot1_h2_std),7));
print("Verifying that Quot1_h2_std is contained in Quot1_h1_std");
TestZero(simplify(reduce(Quot1_h2_std,Quot1_h1_std),7));